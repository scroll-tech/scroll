// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import { OwnableUpgradeable } from "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";

import { IZKRollup } from "./IZKRollup.sol";
import { AppendOnlyMerkleTree } from "../../libraries/common/AppendOnlyMerkleTree.sol";
import { RollupVerifier } from "../../libraries/verifier/RollupVerifier.sol";

/// @title ZKRollup
/// @notice This contract maintains essential data for zk rollup, including:
///
/// 1. a list of pending messages, which will be relayed to layer 2;
/// 2. the block tree generated by layer 2 and it's status.
///
/// @dev the message queue is not used yet, the offline relayer only use events in `L1ScrollMessenger`.
contract ZKRollup is OwnableUpgradeable, AppendOnlyMerkleTree, IZKRollup {
  /**************************************** Events ****************************************/

  /// @notice Emitted when owner updates address of operator
  /// @param _oldOperator The address of old operator.
  /// @param _newOperator The address of new operator.
  event UpdateOperator(address _oldOperator, address _newOperator);

  /// @notice Emitted when owner updates address of messenger
  /// @param _oldMesssenger The address of old messenger contract.
  /// @param _newMesssenger The address of new messenger contract.
  event UpdateMesssenger(address _oldMesssenger, address _newMesssenger);

  /**************************************** Variables ****************************************/

  struct Block {
    // @todo simplify fields later
    BlockHeader header;
    bytes32 transactionRoot;
    bool verified;
  }

  /// @notice The chain id of the corresponding layer 2 chain.
  uint256 public layer2ChainId;

  /// @notice The address of L1ScrollMessenger.
  address public messenger;

  /// @notice The address of operator.
  address public operator;

  /// @dev The index of the first queue element not yet executed.
  /// The operator should change this variable when new block is commited.
  uint256 private nextQueueIndex;

  /// @dev The list of appended message hash.
  bytes32[] private messageQueue;

  /// @notice The hash of the latest finalized block.
  bytes32 public lastFinalizedBlockHash;

  /// @notice Mapping from block hash to block index.
  mapping(bytes32 => Block) public blocks;

  /// @notice Mapping from block height to finalized block hash.
  mapping(uint256 => bytes32) public finalizedBlocks;

  /// @notice Mapping from layer2 message nonce to corresponding message root.
  mapping(uint256 => bytes32) public historicMessageRoot;

  modifier OnlyOperator() {
    // @todo In the decentralize mode, it should be only called by a list of validator.
    require(msg.sender == operator, "caller not operator");
    _;
  }

  /**************************************** Constructor ****************************************/

  function initialize(uint256 _chainId) public initializer {
    OwnableUpgradeable.__Ownable_init();

    layer2ChainId = _chainId;

    _initializeMerkleTree();
  }

  /**************************************** View Functions ****************************************/

  /// @inheritdoc IZKRollup
  function getMessageHashByIndex(uint256 _index) external view returns (bytes32) {
    return messageQueue[_index];
  }

  /// @inheritdoc IZKRollup
  function getNextQueueIndex() external view returns (uint256) {
    return nextQueueIndex;
  }

  /// @notice Return the total number of appended message.
  function getQeueuLength() external view returns (uint256) {
    return messageQueue.length;
  }

  /// @inheritdoc IZKRollup
  function layer2GasLimit(uint256) public view virtual returns (uint256) {
    // hardcode for now
    return 30000000;
  }

  /// @inheritdoc IZKRollup
  function verifyMessageStateProof(uint256 _blockNumber, uint256 _nonce) external view override returns (bytes32) {
    if (finalizedBlocks[_blockNumber] != bytes32(0)) {
      return bytes32(0);
    }
    Block storage _block = blocks[lastFinalizedBlockHash];
    require(uint256(_block.header.blockHeight) >= _blockNumber, "block not finalized");
    return historicMessageRoot[_nonce];
  }

  /**************************************** Mutated Functions ****************************************/

  /// @inheritdoc IZKRollup
  function appendMessage(
    address _sender,
    address _target,
    uint256 _value,
    uint256 _fee,
    uint256 _deadline,
    bytes memory _message,
    uint256 _gasLimit
  ) external override returns (uint256) {
    // currently make only messenger to call
    require(msg.sender == messenger, "caller not messenger");
    uint256 _nonce = messageQueue.length;

    // @todo may change it later
    bytes32 _messageHash = keccak256(
      abi.encodePacked(_sender, _target, _value, _fee, _deadline, _nonce, _message, _gasLimit)
    );
    messageQueue.push(_messageHash);

    return _nonce;
  }

  /// @notice Import layer 2 genesis block
  function importGenesisBlock(BlockHeader memory _genesis) external onlyOwner {
    require(lastFinalizedBlockHash == bytes32(0), "genesis block imported");
    require(_genesis.blockHash != bytes32(0), "invalid block hash");
    require(_genesis.blockHeight == 0, "not genesis block");
    require(_genesis.parentHash == bytes32(0), "parent hash not empty");

    Block storage _block = blocks[_genesis.blockHash];
    _block.header = _genesis;
    _block.verified = true; // force commited

    lastFinalizedBlockHash = _genesis.blockHash;
    finalizedBlocks[0] = _genesis.blockHash;

    emit CommitBlock(_genesis.blockHash, 0, bytes32(0));
  }

  /// @inheritdoc IZKRollup
  function commitBlock(
    BlockHeader memory _header,
    Layer2Transaction[] memory _txn,
    bytes32[] memory _pendingMessages
  ) external override OnlyOperator {
    Block storage _block = blocks[_header.blockHash];
    require(_block.header.blockHash == bytes32(0), "Block has been committed before");
    require(blocks[_header.parentHash].header.blockHash != bytes32(0), "Parent hasn't been committed");

    uint256 _parentHeight = blocks[_header.parentHash].header.blockHeight;
    // solhint-disable-next-line reason-string
    require(_parentHeight + 1 == _header.blockHeight, "Block height and parent block height mismatch");

    bytes32[] memory _hashes = new bytes32[](_txn.length);
    for (uint256 i = 0; i < _txn.length; i++) {
      // @todo use rlp
      _hashes[i] = keccak256(
        abi.encode(
          _txn[i].caller,
          _txn[i].nonce,
          _txn[i].target,
          _txn[i].gas,
          _txn[i].gasPrice,
          _txn[i].value,
          _txn[i].data
        )
      );
    }
    _block.header = _header;
    _block.transactionRoot = keccak256(abi.encode(_hashes));

    // @todo maybe there are better way to verify
    for (uint256 i = 0; i < _pendingMessages.length; i++) {
      (uint256 _index, bytes32 _root) = _appendMessageHash(_pendingMessages[i]);
      historicMessageRoot[_index] = _root;
    }

    emit CommitBlock(_header.blockHash, _header.blockHeight, _header.parentHash);
  }

  /// @inheritdoc IZKRollup
  function revertBlock(bytes32 _blockHash) external override OnlyOperator {
    Block storage _block = blocks[_blockHash];
    require(_block.header.blockHash != bytes32(0), "No such block");
    require(!_block.verified, "Unable to revert verified block");

    delete blocks[_blockHash];

    emit RevertBlock(_blockHash);
  }

  /// @inheritdoc IZKRollup
  function finalizeBlockWithProof(
    bytes32 _blockHash,
    uint256[] memory _proof,
    uint256[] memory _instances
  ) external override OnlyOperator {
    Block storage _block = blocks[_blockHash];
    require(_block.header.blockHash != bytes32(0), "No such block");
    require(!_block.verified, "Block already verified");

    // @note skip parent check for now, since we may not prove blocks in order.
    // bytes32 _parentHash = _block.header.parentHash;
    // require(lastFinalizedBlockHash == _parentHash, "parent not latest finalized");
    // this check below is not needed, just incase
    // require(blocks[_parentHash].verified, "parent not verified");

    // @todo add verification logic
    RollupVerifier.verify(_proof, _instances);

    uint256 _height = _block.header.blockHeight; // gas saving
    _block.verified = true;
    finalizedBlocks[_height] = _blockHash;
    Block storage _finalizedBlock = blocks[lastFinalizedBlockHash];
    if (_height > _finalizedBlock.header.blockHeight) {
      lastFinalizedBlockHash = _blockHash;
    }
    emit FinalizeBlock(_blockHash, uint64(_height));
  }

  /**************************************** Restricted Functions ****************************************/

  /// @notice Update the address of operator.
  /// @dev This function can only called by contract owner.
  /// @param _newOperator The new operator address to update.
  function updateOperator(address _newOperator) external onlyOwner {
    address _oldOperator = operator;
    require(_oldOperator != _newOperator, "change to same operator");

    operator = _newOperator;

    emit UpdateOperator(_oldOperator, _newOperator);
  }

  /// @notice Update the address of messenger.
  /// @dev This function can only called by contract owner.
  /// @param _newMessenger The new messenger address to update.
  function updateMessenger(address _newMessenger) external onlyOwner {
    address _oldMessenger = messenger;
    require(_oldMessenger != _newMessenger, "change to same messenger");

    messenger = _newMessenger;

    emit UpdateMesssenger(_oldMessenger, _newMessenger);
  }
}

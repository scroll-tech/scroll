// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import { OwnableUpgradeable } from "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";

import { IZKRollup } from "./IZKRollup.sol";
import { RollupVerifier } from "../../libraries/verifier/RollupVerifier.sol";

// solhint-disable reason-string

/// @title ZKRollup
/// @notice This contract maintains essential data for zk rollup, including:
///
/// 1. a list of pending messages, which will be relayed to layer 2;
/// 2. the block tree generated by layer 2 and it's status.
///
/// @dev the message queue is not used yet, the offline relayer only use events in `L1ScrollMessenger`.
contract ZKRollup is OwnableUpgradeable, IZKRollup {
  /**********
   * Events *
   **********/

  /// @notice Emitted when owner updates the status of sequencer.
  /// @param account The address of account updated.
  /// @param status The status of the account updated.
  event UpdateSequencer(address account, bool status);

  /*************
   * Constants *
   *************/

  /// @dev The maximum number of blocks in on batch.
  uint256 private constant MAX_NUM_BLOCKS_IN_BATCH = 100;

  /// @notice The chain id of the corresponding layer 2 chain.
  uint256 public immutable layer2ChainId;

  /***********
   * Structs *
   ***********/

  // subject to change
  struct BatchStored {
    // The state root of previous batch.
    // The first batch will use 0x0 for prevStateRoot
    bytes32 prevStateRoot;
    // The state root of the last block in this batch.
    bytes32 currStateRoot;
    // The withdraw trie root of the last block in this batch.
    bytes32 withdrawTrieRoot;
    // The hash of public input.
    bytes32 publicInputHash;
    // The index of the batch.
    uint64 batchIndex;
    // The timestamp of the last block in this batch.
    uint64 timestamp;
    // The number of transactions in this batch, both L1 & L2 txs.
    uint64 numTransactions;
    // The number of l1 messages in this batch.
    uint64 numL1Messages;
    // Whether the batch is finalized.
    bool finalized;
    // do we need to store the parent hash of this batch?
  }

  /*************
   * Variables *
   *************/

  /// @notice Whether an account is a sequencer.
  mapping(address => bool) public isSequencer;

  /// @notice The latest finalized batch hash.
  bytes32 public lastFinalizedBatchHash;

  /// @notice Mapping from batch id to batch struct.
  mapping(bytes32 => BatchStored) public batches;

  /// @notice Mapping from batch index to finalized batch hash.
  mapping(uint256 => bytes32) public finalizedBatches;

  /**********************
   * Function Modifiers *
   **********************/

  modifier OnlySequencer() {
    // @todo In the decentralize mode, it should be only called by a list of validator.
    require(isSequencer[msg.sender], "caller not sequencer");
    _;
  }

  /***************
   * Constructor *
   ***************/

  constructor(uint256 _chainId) {
    layer2ChainId = _chainId;
  }

  function initialize() public initializer {
    OwnableUpgradeable.__Ownable_init();
  }

  /*************************
   * Public View Functions *
   *************************/

  /// @inheritdoc IZKRollup
  function isBatchFinalized(bytes32 _batchHash) external view override returns (bool) {
    return batches[_batchHash].finalized;
  }

  /// @inheritdoc IZKRollup
  function isBatchFinalized(uint256 _batchIndex) external view override returns (bool) {
    return finalizedBatches[_batchIndex] != bytes32(0);
  }

  /// @inheritdoc IZKRollup
  function layer2GasLimit(uint256) public view virtual override returns (uint256) {
    // hardcode for now
    return 30000000;
  }

  /// @inheritdoc IZKRollup
  function getL2MessageRoot(bytes32 _batchHash) external view override returns (bytes32) {
    return batches[_batchHash].withdrawTrieRoot;
  }

  /****************************
   * Public Mutated Functions *
   ****************************/

  /// @notice Import layer 2 genesis block
  function importGenesisBatch(Batch memory _genesisBatch) external {
    require(lastFinalizedBatchHash == bytes32(0), "Genesis batch imported");
    require(_genesisBatch.blocks.length == 1, "Not exact one block in genesis");

    BlockContext memory _genesisBlock = _genesisBatch.blocks[0];

    require(_genesisBlock.blockHash != bytes32(0), "Block hash is zero");
    require(_genesisBlock.blockNumber == 0, "Block is not genesis");
    require(_genesisBlock.parentHash == bytes32(0), "Parent hash not empty");
    require(_genesisBlock.parentHash == bytes32(0), "Parent hash not empty");

    bytes32 _batchHash = _commitBatch(_genesisBatch);

    lastFinalizedBatchHash = _batchHash;
    finalizedBatches[0] = _batchHash;
    batches[_batchHash].finalized = true;

    emit FinalizeBatch(_batchHash);
  }

  /// @inheritdoc IZKRollup
  function commitBatch(Batch memory _batch) public override OnlySequencer {
    _commitBatch(_batch);
  }

  /// @inheritdoc IZKRollup
  function commitBatches(Batch[] memory _batches) public override OnlySequencer {
    for (uint256 i = 0; i < _batches.length; i++) {
      _commitBatch(_batches[i]);
    }
  }

  /// @inheritdoc IZKRollup
  function revertBatch(bytes32 _batchHash) external override OnlySequencer {
    BatchStored storage _batch = batches[_batchHash];

    require(_batch.publicInputHash != bytes32(0), "No such batch");
    require(!_batch.finalized, "Unable to revert verified batch");

    // delete commited batch
    delete batches[_batchHash];

    emit RevertBatch(_batchHash);
  }

  /// @inheritdoc IZKRollup
  function finalizeBatchWithProof(
    bytes32 _batchHash,
    uint256[] memory _proof,
    uint256[] memory _instances
  ) external override OnlySequencer {
    BatchStored storage _batch = batches[_batchHash];
    require(_batch.publicInputHash != bytes32(0), "No such batch");
    require(!_batch.finalized, "Batch already verified");

    // @note skip parent check for now, since we may not prove blocks in order.
    // bytes32 _parentHash = _block.header.parentHash;
    // require(lastFinalizedBlockHash == _parentHash, "parent not latest finalized");
    // this check below is not needed, just incase
    // require(blocks[_parentHash].verified, "parent not verified");

    // @todo add verification logic
    RollupVerifier.verify(_proof, _instances);

    uint256 _batchIndex = _batch.batchIndex;
    finalizedBatches[_batchIndex] = _batchHash;
    _batch.finalized = true;

    BatchStored storage _finalizedBatch = batches[lastFinalizedBatchHash];
    if (_batchIndex > _finalizedBatch.batchIndex) {
      lastFinalizedBatchHash = _batchHash;
    }

    emit FinalizeBatch(_batchHash);
  }

  /************************
   * Restricted Functions *
   ************************/

  /// @notice Update the status of sequencer.
  /// @dev This function can only called by contract owner.
  /// @param _account The address of account to update.
  /// @param _status The status of the account to update.
  function updateSequencer(address _account, bool _status) external onlyOwner {
    isSequencer[_account] = _status;

    emit UpdateSequencer(_account, _status);
  }

  /**********************
   * Internal Functions *
   **********************/

  /// @dev Internal function to commit a batch.
  /// @param _batch The batch to commit.
  function _commitBatch(Batch memory _batch) internal returns (bytes32) {
    /*
    // check whether the batch is empty
    require(_batch.blocks.length > 0, "Batch is empty");

    bytes32 _batchHash = _batch.blocks[_batch.blocks.length - 1].blockHash;
    bytes32 _batchId = _computeBatchId(_batchHash, _batch.parentHash, _batch.batchIndex);
    Layer2BatchStored storage _batchStored = batches[_batchId];

    // check whether the batch is commited before
    require(_batchStored.batchHash == bytes32(0), "Batch has been committed before");

    // make sure the parent batch is commited before
    Layer2BlockStored storage _parentBlock = blocks[_batch.parentHash];
    require(_parentBlock.transactionRoot != bytes32(0), "Parent batch hasn't been committed");
    require(_parentBlock.batchIndex + 1 == _batch.batchIndex, "Batch index and parent batch index mismatch");

    // check whether the blocks are correct.
    unchecked {
      uint256 _expectedBlockHeight = _parentBlock.blockHeight + 1;
      bytes32 _expectedParentHash = _batch.parentHash;
      for (uint256 i = 0; i < _batch.blocks.length; i++) {
        Layer2BlockHeader memory _block = _batch.blocks[i];
        require(_verifyBlockHash(_block), "Block hash verification failed");
        require(_block.parentHash == _expectedParentHash, "Block parent hash mismatch");
        require(_block.blockHeight == _expectedBlockHeight, "Block height mismatch");
        require(blocks[_block.blockHash].transactionRoot == bytes32(0), "Block has been commited before");

        _expectedBlockHeight += 1;
        _expectedParentHash = _block.blockHash;
      }
    }

    // do block commit
    for (uint256 i = 0; i < _batch.blocks.length; i++) {
      Layer2BlockHeader memory _block = _batch.blocks[i];
      Layer2BlockStored storage _blockStored = blocks[_block.blockHash];
      _blockStored.parentHash = _block.parentHash;
      _blockStored.transactionRoot = _computeTransactionRoot(_block.txs);
      _blockStored.blockHeight = _block.blockHeight;
      _blockStored.batchIndex = _batch.batchIndex;
    }

    _batchStored.batchHash = _batchHash;
    _batchStored.parentHash = _batch.parentHash;
    _batchStored.batchIndex = _batch.batchIndex;

    emit CommitBatch(_batchId, _batchHash, _batch.batchIndex, _batch.parentHash);
    */
  }

  /// @dev Internal function to compute a unique batch id for mapping.
  /// @param _batchHash The hash of the batch.
  /// @param _parentHash The hash of the batch.
  /// @param _batchIndex The index of the batch.
  /// @return Return the computed batch id.
  function _computeBatchId(
    bytes32 _batchHash,
    bytes32 _parentHash,
    uint256 _batchIndex
  ) internal pure returns (bytes32) {
    return keccak256(abi.encode(_batchHash, _parentHash, _batchIndex));
  }
}

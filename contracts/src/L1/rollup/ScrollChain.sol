// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import {OwnableUpgradeable} from "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";

import {IL1MessageQueue} from "./IL1MessageQueue.sol";
import {IScrollChain} from "./IScrollChain.sol";
import {RollupVerifier} from "../../libraries/verifier/RollupVerifier.sol";

// solhint-disable reason-string

/// @title ScrollChain
/// @notice This contract maintains essential data for scroll rollup, including:
///
/// 1. a list of pending messages, which will be relayed to layer 2;
/// 2. the block tree generated by layer 2 and it's status.
///
/// @dev the message queue is not used yet, the offline relayer only use events in `L1ScrollMessenger`.
contract ScrollChain is OwnableUpgradeable, IScrollChain {
    /**********
     * Events *
     **********/

    /// @notice Emitted when owner updates the status of sequencer.
    /// @param account The address of account updated.
    /// @param status The status of the account updated.
    event UpdateSequencer(address indexed account, bool status);

    /*************
     * Constants *
     *************/

    /// @dev The maximum number of transaction in on batch.
    uint256 public immutable maxNumTxInBatch;

    /// @dev The hash used for padding public inputs.
    bytes32 public immutable paddingTxHash;

    /// @notice The chain id of the corresponding layer 2 chain.
    uint256 public immutable layer2ChainId;

    /***********
     * Structs *
     ***********/

    // subject to change
    struct BatchStored {
        // The state root of the last block in this batch.
        bytes32 newStateRoot;
        // The withdraw trie root of the last block in this batch.
        bytes32 withdrawTrieRoot;
        // The parent batch hash.
        bytes32 parentBatchHash;
        // The index of the batch.
        uint64 batchIndex;
        // The timestamp of the last block in this batch.
        uint64 timestamp;
        // The number of transactions in this batch, both L1 & L2 txs.
        uint64 numTransactions;
        // The total number of L1 messages included after this batch.
        uint64 totalL1Messages;
        // Whether the batch is finalized.
        bool finalized;
    }

    /*************
     * Variables *
     *************/

    /// @notice The address of L1MessageQueue.
    address public messageQueue;

    /// @notice Whether an account is a sequencer.
    mapping(address => bool) public isSequencer;

    /// @notice The latest finalized batch hash.
    bytes32 public lastFinalizedBatchHash;

    /// @notice Mapping from batch id to batch struct.
    mapping(bytes32 => BatchStored) public batches;

    /// @notice Mapping from batch index to finalized batch hash.
    mapping(uint256 => bytes32) public finalizedBatches;

    /**********************
     * Function Modifiers *
     **********************/

    modifier OnlySequencer() {
        // @todo In the decentralize mode, it should be only called by a list of validator.
        require(isSequencer[msg.sender], "caller not sequencer");
        _;
    }

    /***************
     * Constructor *
     ***************/

    constructor(
        uint256 _chainId,
        uint256 _maxNumTxInBatch,
        bytes32 _paddingTxHash
    ) {
        layer2ChainId = _chainId;
        maxNumTxInBatch = _maxNumTxInBatch;
        paddingTxHash = _paddingTxHash;
    }

    function initialize(address _messageQueue) public initializer {
        OwnableUpgradeable.__Ownable_init();

        messageQueue = _messageQueue;
    }

    /*************************
     * Public View Functions *
     *************************/

    /// @inheritdoc IScrollChain
    function isBatchFinalized(bytes32 _batchHash) external view override returns (bool) {
        BatchStored storage _batch = batches[_batchHash];
        if (_batch.newStateRoot == bytes32(0)) {
            return false;
        }
        return batches[lastFinalizedBatchHash].batchIndex >= _batch.batchIndex;
    }

    /// @inheritdoc IScrollChain
    function getL2MessageRoot(bytes32 _batchHash) external view override returns (bytes32) {
        return batches[_batchHash].withdrawTrieRoot;
    }

    /*****************************
     * Public Mutation Functions *
     *****************************/

    /// @notice Import layer 2 genesis block
    function importGenesisBatch(Batch memory _genesisBatch) external {
        require(lastFinalizedBatchHash == bytes32(0), "Genesis batch imported");
        require(_genesisBatch.blocks.length == 1, "Not exact one block in genesis");
        require(_genesisBatch.prevStateRoot == bytes32(0), "Nonzero prevStateRoot");

        BlockContext memory _genesisBlock = _genesisBatch.blocks[0];

        require(_genesisBlock.blockHash != bytes32(0), "Block hash is zero");
        require(_genesisBlock.blockNumber == 0, "Block is not genesis");
        require(_genesisBlock.parentHash == bytes32(0), "Parent hash not empty");

        bytes32 _batchHash = _commitBatch(_genesisBatch);

        lastFinalizedBatchHash = _batchHash;
        finalizedBatches[0] = _batchHash;
        batches[_batchHash].finalized = true;

        emit FinalizeBatch(_batchHash);
    }

    /// @inheritdoc IScrollChain
    function commitBatch(Batch memory _batch) public override OnlySequencer {
        _commitBatch(_batch);
    }

    /// @inheritdoc IScrollChain
    function commitBatches(Batch[] memory _batches) public override OnlySequencer {
        for (uint256 i = 0; i < _batches.length; i++) {
            _commitBatch(_batches[i]);
        }
    }

    /// @inheritdoc IScrollChain
    function revertBatch(bytes32 _batchHash) external override OnlySequencer {
        BatchStored storage _batch = batches[_batchHash];

        require(_batch.newStateRoot != bytes32(0), "No such batch");
        require(!_batch.finalized, "Unable to revert finalized batch");

        // delete committed batch
        delete batches[_batchHash];

        emit RevertBatch(_batchHash);
    }

    /// @inheritdoc IScrollChain
    function finalizeBatchWithProof(
        bytes32 _batchHash,
        uint256[] memory _proof,
        uint256[] memory _instances
    ) external override OnlySequencer {
        BatchStored storage _batch = batches[_batchHash];
        require(_batch.newStateRoot != bytes32(0), "No such batch");
        require(!_batch.finalized, "Batch is already finalized");

        // @note skip parent check for now, since we may not prove blocks in order.
        // bytes32 _parentHash = _block.header.parentHash;
        // require(lastFinalizedBlockHash == _parentHash, "parent not latest finalized");
        // this check below is not needed, just incase
        // require(blocks[_parentHash].verified, "parent not verified");

        // @todo add verification logic
        RollupVerifier.verify(_proof, _instances);

        uint256 _batchIndex = _batch.batchIndex;
        finalizedBatches[_batchIndex] = _batchHash;
        _batch.finalized = true;

        BatchStored storage _finalizedBatch = batches[lastFinalizedBatchHash];
        if (_batchIndex > _finalizedBatch.batchIndex) {
            lastFinalizedBatchHash = _batchHash;
        }

        emit FinalizeBatch(_batchHash);
    }

    /************************
     * Restricted Functions *
     ************************/

    /// @notice Update the status of sequencer.
    /// @dev This function can only called by contract owner.
    /// @param _account The address of account to update.
    /// @param _status The status of the account to update.
    function updateSequencer(address _account, bool _status) external onlyOwner {
        isSequencer[_account] = _status;

        emit UpdateSequencer(_account, _status);
    }

    /**********************
     * Internal Functions *
     **********************/

    /// @dev Internal function to commit a batch.
    /// @param _batch The batch to commit.
    function _commitBatch(Batch memory _batch) internal returns (bytes32) {
        // check whether the batch is empty
        require(_batch.blocks.length > 0, "Batch is empty");

        BatchStored storage _parentBatch = batches[_batch.parentBatchHash];
        require(
            _parentBatch.newStateRoot == _batch.prevStateRoot,
            "prevStateRoot is different from newStateRoot in the parent batch"
        );
        uint64 accTotalL1Messages = _parentBatch.totalL1Messages;

        bytes32 publicInputHash;
        uint64 numTransactionsInBatch;
        uint64 lastBlockTimestamp;
        (publicInputHash, numTransactionsInBatch, accTotalL1Messages, lastBlockTimestamp) = _computePublicInputHash(
            accTotalL1Messages,
            _batch
        );

        BatchStored storage _batchInStorage = batches[publicInputHash];

        require(_batchInStorage.newStateRoot == bytes32(0), "Batch already commited");
        _batchInStorage.newStateRoot = _batch.newStateRoot;
        _batchInStorage.withdrawTrieRoot = _batch.withdrawTrieRoot;
        _batchInStorage.batchIndex = _batch.batchIndex;
        _batchInStorage.parentBatchHash = _batch.parentBatchHash;
        _batchInStorage.timestamp = lastBlockTimestamp;
        _batchInStorage.numTransactions = numTransactionsInBatch;
        _batchInStorage.totalL1Messages = accTotalL1Messages;

        emit CommitBatch(publicInputHash);

        return publicInputHash;
    }

    /// @dev Internal function to compute the public input hash.
    /// @param accTotalL1Messages The number of total L1 messages in previous batch.
    /// @param batch The batch to compute.
    function _computePublicInputHash(uint64 accTotalL1Messages, Batch memory batch)
        internal
        view
        returns (
            bytes32,
            uint64,
            uint64,
            uint64
        )
    {
        uint256 publicInputsPtr;
        // 1. append prevStateRoot, newStateRoot and withdrawTrieRoot to public inputs
        {
            bytes32 prevStateRoot = batch.prevStateRoot;
            bytes32 newStateRoot = batch.newStateRoot;
            bytes32 withdrawTrieRoot = batch.withdrawTrieRoot;
            // number of bytes in public inputs: 32 * 3 + 124 * blocks + 32 * MAX_NUM_TXS
            uint256 publicInputsSize = 32 * 3 + batch.blocks.length * 124 + 32 * maxNumTxInBatch;
            assembly {
                publicInputsPtr := mload(0x40)
                mstore(0x40, add(publicInputsPtr, publicInputsSize))
                mstore(publicInputsPtr, prevStateRoot)
                publicInputsPtr := add(publicInputsPtr, 0x20)
                mstore(publicInputsPtr, newStateRoot)
                publicInputsPtr := add(publicInputsPtr, 0x20)
                mstore(publicInputsPtr, withdrawTrieRoot)
                publicInputsPtr := add(publicInputsPtr, 0x20)
            }
        }

        uint64 numTransactionsInBatch;
        BlockContext memory _block;
        // 2. append block information to public inputs.
        for (uint256 i = 0; i < batch.blocks.length; i++) {
            // validate blocks, we won't check first block against previous batch.
            {
                BlockContext memory _currentBlock = batch.blocks[i];
                if (i > 0) {
                    require(_block.blockHash == _currentBlock.parentHash, "Parent hash mismatch");
                    require(_block.blockNumber + 1 == _currentBlock.blockNumber, "Block number mismatch");
                }
                _block = _currentBlock;
            }

            // append blockHash and parentHash to public inputs
            {
                bytes32 blockHash = _block.blockHash;
                bytes32 parentHash = _block.parentHash;
                assembly {
                    mstore(publicInputsPtr, blockHash)
                    publicInputsPtr := add(publicInputsPtr, 0x20)
                    mstore(publicInputsPtr, parentHash)
                    publicInputsPtr := add(publicInputsPtr, 0x20)
                }
            }
            // append blockNumber and blockTimestamp to public inputs
            {
                uint256 blockNumber = _block.blockNumber;
                uint256 blockTimestamp = _block.timestamp;
                assembly {
                    mstore(publicInputsPtr, shl(192, blockNumber))
                    publicInputsPtr := add(publicInputsPtr, 0x8)
                    mstore(publicInputsPtr, shl(192, blockTimestamp))
                    publicInputsPtr := add(publicInputsPtr, 0x8)
                }
            }
            // append baseFee to public inputs
            {
                uint256 baseFee = _block.baseFee;
                assembly {
                    mstore(publicInputsPtr, baseFee)
                    publicInputsPtr := add(publicInputsPtr, 0x20)
                }
            }
            uint64 numTransactionsInBlock = _block.numTransactions;
            // gasLimit, numTransactions and numL1Messages to public inputs
            {
                uint256 gasLimit = _block.gasLimit;
                uint256 numL1MessagesInBlock = _block.numL1Messages;
                assembly {
                    mstore(publicInputsPtr, shl(192, gasLimit))
                    publicInputsPtr := add(publicInputsPtr, 0x8)
                    mstore(publicInputsPtr, shl(240, numTransactionsInBlock))
                    publicInputsPtr := add(publicInputsPtr, 0x2)
                    mstore(publicInputsPtr, shl(240, numL1MessagesInBlock))
                    publicInputsPtr := add(publicInputsPtr, 0x2)
                }
            }
            numTransactionsInBatch += numTransactionsInBlock;
        }
        require(numTransactionsInBatch <= maxNumTxInBatch, "Too many transactions in batch");

        // 3. append transaction hash to public inputs.
        address _messageQueue = messageQueue;
        uint256 _l2TxnPtr;
        {
            bytes memory l2Transactions = batch.l2Transactions;
            assembly {
                _l2TxnPtr := add(l2Transactions, 0x20)
            }
        }
        for (uint256 i = 0; i < batch.blocks.length; i++) {
            uint256 numL1MessagesInBlock = batch.blocks[i].numL1Messages;
            while (numL1MessagesInBlock > 0) {
                bytes32 hash = IL1MessageQueue(_messageQueue).getCrossDomainMessage(uint64(accTotalL1Messages));
                assembly {
                    mstore(publicInputsPtr, hash)
                    publicInputsPtr := add(publicInputsPtr, 0x20)
                }
                unchecked {
                    accTotalL1Messages += 1;
                    numL1MessagesInBlock -= 1;
                }
            }
            numL1MessagesInBlock = batch.blocks[i].numL1Messages;
            uint256 numTransactionsInBlock = batch.blocks[i].numTransactions;
            for (uint256 j = numL1MessagesInBlock; j < numTransactionsInBlock; ++j) {
                bytes32 hash;
                assembly {
                    let txPayloadLength := shr(224, mload(_l2TxnPtr))
                    _l2TxnPtr := add(_l2TxnPtr, 4)
                    _l2TxnPtr := add(_l2TxnPtr, txPayloadLength)
                    hash := keccak256(sub(_l2TxnPtr, txPayloadLength), txPayloadLength)
                    mstore(publicInputsPtr, hash)
                    publicInputsPtr := add(publicInputsPtr, 0x20)
                }
            }
        }

        // 4. append padding transaction to public inputs.
        bytes32 txHashPadding = paddingTxHash;
        for (uint256 i = numTransactionsInBatch; i < maxNumTxInBatch; i++) {
            assembly {
                mstore(publicInputsPtr, txHashPadding)
                publicInputsPtr := add(publicInputsPtr, 0x20)
            }
        }

        // 5. compute public input hash
        bytes32 publicInputHash;
        {
            uint256 publicInputsSize = 32 * 3 + batch.blocks.length * 124 + 32 * maxNumTxInBatch;
            assembly {
                publicInputHash := keccak256(sub(publicInputsPtr, publicInputsSize), publicInputsSize)
            }
        }

        return (publicInputHash, numTransactionsInBatch, accTotalL1Messages, _block.timestamp);
    }
}
